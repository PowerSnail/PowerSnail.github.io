<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="author" content="PowerSnail" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <meta name="theme-color" content="#bd1b37" />

    <title>
      Production of Sentences and Properties of Languages: Parsing Techniques
      Notes (2) · SnailShell
    </title>

    <meta
      property="og:title"
      content="Production of Sentences and Properties of Languages: Parsing Techniques Notes (2)"
    />
    <meta property="og:site_name" content="SnailShell" />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://powersnail.com/2016/parsing-techniques-notes02/"
    />

    <meta
      property="og:image"
      content="https://powersnail.com/icons/snail.svg"
    />

    <meta
      name="description"
      content="some notes on Parsing Techniques A Practical Guide"
    />
    <meta
      property="og:description"
      content="some notes on Parsing Techniques A Practical Guide"
    />

    <link
      rel="canonical"
      href="https://powersnail.com/2016/parsing-techniques-notes02/"
    />

    <script
      type="text/javascript"
      id="MathJax-script"
      src="/js/bundle.39b4c9e45c7f60379025444391711d5dc496457cd3480b1edb45bf24649fd217.js"
      defer
    ></script>

    <link id="main-css" rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <div
      style="
        height: 50px;
        width: 100%;
        grid-column: 1/-1;
        grid-template-columns: subgrid;
        background-color: #f57029ff;
        display: grid;
      "
    >
      <div style="grid-column: 3/-3; position: relative">
        <img
          src="/images/halloween.webp"
          width="256px"
          height="48px"
          style="
            position: absolute;
            left: 0;
            top: 0;
            max-width: 100%;
            height: auto;
          "
        />
      </div>
    </div>

    <header>
      <article>
        <nav class="site-nav">
          <a href="/" class="site-title">
            <span class="site-title-text">Snail's Shell</span>
          </a>
          <div class="site-title-fill"></div>
          <a href="/posts/" class="nav-link"> Posts </a>
          <details>
            <summary>
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="1.5"
                stroke="currentColor"
                class="icon"
                width="16"
                height="16"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  d="M12 4.5v15m7.5-7.5h-15"
                />
              </svg>

              More
            </summary>
            <div class="site-title-more">
              <a href="/index.xml" class="nav-link"> RSS </a>
              <a href="/about/" class="nav-link"> About </a>
              <a href="/sheet-music/" class="nav-link"> Sheet Music </a>
              <a href="/stats/" class="nav-link"> Blog Stats </a>
              <a href="/cat_dot/" class="nav-link"> Moving Red Dot for Cat </a>
              <a href="/game_of_life/" class="nav-link"> Game of Life </a>
            </div>
          </details>
        </nav>
      </article>
    </header>

    <main>
      <article id="post-main">
        <h1>
          Production of Sentences and Properties of Languages: Parsing
          Techniques Notes (2)
        </h1>

        <div id="title-subtitle">
          some notes on Parsing Techniques A Practical Guide
        </div>

        <div class="metadata">
          <time datetime="2016-02-26T00:00:00Z">26 Feb 2016</time>
          · 537 words · 3 minutes read
        </div>
        <hr />

        <h2 id="generating-sentences">
          Generating Sentences
          <a href="#generating-sentences"><small>##</small></a>
        </h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th></th>
                <th>sentence <em>vs.</em> sentential</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>sentence</td>
                <td>
                  all symbols belongs to terminals (a valid element of the
                  language)
                </td>
              </tr>
              <tr>
                <td>sentential</td>
                <td>
                  may contain non-terminals, an intermediate form during
                  sentence production
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <h4 id="example">
          Example:
          <a href="#example"><small>####</small></a>
        </h4>
        <p>
          For a language where $V_N = {P, Q} \land V_T = {a, b, c, d}$, a valid
          sentential would be $aP$; a valid sentence would be $ac$.
        </p>
        <h3 id="type-0-and-type-1-cs-languages">
          Type 0 and Type 1 (CS) Languages
          <a href="#type-0-and-type-1-cs-languages"><small>###</small></a>
        </h3>
        <p>
          <strong>Breadth-first Production</strong>: for each sentential, make
          copies of it for each applicable rule. Then, repeat the operation on
          each copy. If there is no <em>non-terminal</em> in the sentential, it
          is then a sentence, and could be printed and discarded in the
          production.
        </p>
        <p>
          This process may be infinitely long, but it is guaranteed that an
          arbitrary sentence will definitely be produced.
        </p>
        <h4 id="two-remarks-about-cs-language-sentence-production">
          Two Remarks about CS Language Sentence Production
          <a href="#two-remarks-about-cs-language-sentence-production"
            ><small>####</small></a
          >
        </h4>
        <ol>
          <li>
            <p>
              We cannot decide whether a CS language is empty, i.e. whether its
              rules could produce a sentence. <br />
              The process takes infinite time, and therefore is
              <em>undecidable</em>.
            </p>
            <ul>
              <li>
                It is possible to prove a CS language being non-empty by giving
                an example of sentence it generates.
              </li>
              <li>It is impossible to prove a CS language is empty.</li>
            </ul>
          </li>
          <li>
            <p>
              General parsing of CS language is <em>unsolvable</em>. We cannot
              produce a list of sentences in a CS language in order by length.
              Because it is context-sensitive, the length of the sentence could
              &ldquo;shrink&rdquo; suddenly and unpredictably. <br />
              As a result, we cannot determine a sentence is not in the
              language; there is always possibility that it may show up in
              further production.
            </p>
          </li>
        </ol>
        <p>Type 0 language has the same properties.</p>
        <h3 id="type-2-cf-language">
          Type 2 (CF) Language
          <a href="#type-2-cf-language"><small>###</small></a>
        </h3>
        <p>
          Monotonic nature of CF language means that the length of sentence will
          not &ldquo;shrink&rdquo;. Therefore, we could solve the two problems
          of CS language by a rather simple algorithm:
        </p>
        <ol>
          <li>Scan rules that have terminal on right-hand side,</li>
          <li>marking those as productive;</li>
          <li>scan rules that have productive on right-hand side,</li>
          <li>
            repeat 2, 3 until meeting the start symbol or no new productive
            symbols could be found
          </li>
        </ol>
        <p>
          If the above process is able to reach the start symbol then it is not
          empty; otherwise, it finds no way up to the start symbol, the language
          is empty.
        </p>
        <p>
          The length of sentence does not shrink in CF language. Therefore, we
          could determine a sentence&rsquo;s existence. If we meet the sentence
          obviously, it belongs to the language. If we keep producing and exceed
          the length of the sentence, then further production on the sentential
          will definitely not produce the sentence. We could therefore decide
          the inclusion of an arbitrary sentence of finite length in finite
          time.
        </p>
        <h3 id="type-3-regular-language">
          Type 3 (Regular) Language
          <a href="#type-3-regular-language"><small>###</small></a>
        </h3>
        <p>
          Regular language has rules that right-hand side contains at most one
          non-terminal, and it should be the rightmost symbol. Regular language
          could be written as regular expressions that is composed of only
          terminals and regular operators. As a result, if a non-empty regular
          expression could be constructed, then the language is non-empty.
        </p>
        <p>
          It is also possible to enumerate sentences without breath-first
          production, as only one non-terminal could be replaced in each
          sentential. When looking for a sentence $K$ of length $l$, if the
          length of sentential exceeds $l$, then $K$ cannot be included in the
          language. Finding any sentence in the process would prove that the
          language is not empty.
        </p>
        <!-- page -->

        <footer>
          <section class="footer-meta">
            <p>
              <svg
                aria-label="tags"
                class="icon"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="currentColor"
                width="16"
                height="16"
              >
                <path
                  fill-rule="evenodd"
                  d="M5.25 2.25a3 3 0 00-3 3v4.318a3 3 0 00.879 2.121l9.58 9.581c.92.92 2.39 1.186 3.548.428a18.849 18.849 0 005.441-5.44c.758-1.16.492-2.629-.428-3.548l-9.58-9.581a3 3 0 00-2.122-.879H5.25zM6.375 7.5a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z"
                  clip-rule="evenodd"
                />
              </svg>
              <a href="/tags/computer-science"><code>computer science</code></a
              >, <a href="/tags/notes"><code>notes</code></a
              >, <a href="/tags/study"><code>study</code></a
              >, <a href="/tags/parsing"><code>parsing</code></a>
            </p>
          </section>

          <section>
            <p>
              Leave a comment via email:
              <a
                href="mailto:comment.2016.parsing-techniques-notes02@powersnail.com"
                >comment.2016.parsing-techniques-notes02@powersnail.com</a
              >.
            </p>
          </section>
        </footer>
      </article>
    </main>
    <footer>
      <article><div>© PowerSnail 2016</div></article>
    </footer>
  </body>
</html>
