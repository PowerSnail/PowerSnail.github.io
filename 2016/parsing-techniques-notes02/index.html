<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src 'self' https://snailshell.goatcounter.com/count https://mirrors.creativecommons.org/; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'">
    <meta name="author" content="PowerSnail">
    <meta name="description" content="some notes on Parsing Techniques A Practical Guide">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#af3000">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="theme-color" content="#C73403">
    <title>
      Production of Sentences and Properties of Languages: Parsing Techniques Notes (2) · SnailShell
    </title>
    <link rel="prefetch" href="/images/front-cover.webp" as="image" crossorigin="">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="canonical" href="https://powersnail.com/2016/parsing-techniques-notes02/">
    <script type="text/javascript" id="MathJax-script" src="/js/bundle.cc6d92b034817d3a3e6e3835b40e09bd99b88fcbe2b160a0dd4220b82b21c3cc.js" defer></script>
  </head>
  <body>
    <header>
      <a href="/">SnailShell</a>
      <nav>
        <a type="button" href="/posts/">Posts</a> <a type="button" href="/status/">Status</a> <a type="button" href="/about/">About</a>
      </nav>
    </header><img class="goatcounter" alt="" width="1" height="1" src="https://snailshell.goatcounter.com/count?p=%2f2016%2fparsing-techniques-notes02%2f&amp;t=Production%20of%20Sentences%20and%20Properties%20of%20Languages%3a%20Parsing%20Techniques%20Notes%20%282%29">
    <main>
      <article id="post-main">
        <h1>
          Production of Sentences and Properties of Languages: Parsing Techniques Notes (2)
        </h1>
        <hr>
        <div class="metadata">
          2016-02-26 · 531 words · 3 minutes read
        </div>
        <h2 id="generating-sentences">
          Generating Sentences
        </h2>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th></th>
                <th>
                  sentence <em>vs.</em> sentential
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  sentence
                </td>
                <td>
                  all symbols belongs to terminals (a valid element of the language)
                </td>
              </tr>
              <tr>
                <td>
                  sentential
                </td>
                <td>
                  may contain non-terminals, an intermediate form during sentence production
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <h4 id="example">
          Example:
        </h4>
        <p>
          For a language where $V_N = {P, Q} \land V_T = {a, b, c, d}$, a valid sentential would be $aP$; a valid sentence would be $ac$.
        </p>
        <h3 id="type-0-and-type-1-cs-languages">
          Type 0 and Type 1 (CS) Languages
        </h3>
        <p>
          <strong>Breadth-first Production</strong>: for each sentential, make copies of it for each applicable rule. Then, repeat the operation on each copy. If there is no <em>non-terminal</em> in the sentential, it is then a sentence, and could be printed and discarded in the production.
        </p>
        <p>
          This process may be infinitely long, but it is guaranteed that an arbitrary sentence will definitely be produced.
        </p>
        <h4 id="two-remarks-about-cs-language-sentence-production">
          Two Remarks about CS Language Sentence Production
        </h4>
        <ol>
          <li>
            <p>
              We cannot decide whether a CS language is empty, i.e. whether its rules could produce a sentence.<br>
              The process takes infinite time, and therefore is <em>undecidable</em>.
            </p>
            <ul>
              <li>It is possible to prove a CS language being non-empty by giving an example of sentence it generates.
              </li>
              <li>It is impossible to prove a CS language is empty.
              </li>
            </ul>
          </li>
          <li>
            <p>
              General parsing of CS language is <em>unsolvable</em>. We cannot produce a list of sentences in a CS language in order by length. Because it is context-sensitive, the length of the sentence could “shrink” suddenly and unpredictably.<br>
              As a result, we cannot determine a sentence is not in the language; there is always possibility that it may show up in further production.
            </p>
          </li>
        </ol>
        <p>
          Type 0 language has the same properties.
        </p>
        <h3 id="type-2-cf-language">
          Type 2 (CF) Language
        </h3>
        <p>
          Monotonic nature of CF language means that the length of sentence will not “shrink”. Therefore, we could solve the two problems of CS language by a rather simple algorithm:
        </p>
        <ol>
          <li>Scan rules that have terminal on right-hand side,
          </li>
          <li>marking those as productive;
          </li>
          <li>scan rules that have productive on right-hand side,
          </li>
          <li>repeat 2, 3 until meeting the start symbol or no new productive symbols could be found
          </li>
        </ol>
        <p>
          If the above process is able to reach the start symbol then it is not empty; otherwise, it finds no way up to the start symbol, the language is empty.
        </p>
        <p>
          The length of sentence does not shrink in CF language. Therefore, we could determine a sentence’s existence. If we meet the sentence obviously, it belongs to the language. If we keep producing and exceed the length of the sentence, then further production on the sentential will definitely not produce the sentence. We could therefore decide the inclusion of an arbitrary sentence of finite length in finite time.
        </p>
        <h3 id="type-3-regular-language">
          Type 3 (Regular) Language
        </h3>
        <p>
          Regular language has rules that right-hand side contains at most one non-terminal, and it should be the rightmost symbol. Regular language could be written as regular expressions that is composed of only terminals and regular operators. As a result, if a non-empty regular expression could be constructed, then the language is non-empty.
        </p>
        <p>
          It is also possible to enumerate sentences without breath-first production, as only one non-terminal could be replaced in each sentential. When looking for a sentence $K$ of length $l$, if the length of sentential exceeds $l$, then $K$ cannot be included in the language. Finding any sentence in the process would prove that the language is not empty.
        </p><!-- page -->
        <div>
          <a class="tag" href="/tags/computer-science">computer science</a> <a class="tag" href="/tags/notes">notes</a> <a class="tag" href="/tags/study">study</a> <a class="tag" href="/tags/parsing">parsing</a>
        </div>
        <footer>
          <p id="cc">
            This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0 <img alt="Creative Commons License CC BY-SA 4.0" src="/images/cc-all.svg" style="height:1.4em; width: auto;" loading="lazy" width="30" height="11"></a>
          </p>
        </footer>
      </article>
    </main>
    <footer>
      <nav>
        <a class="icon-prefix rss" href="/index.xml">RSS</a> <a class="icon-prefix brand-github" href="https://github.com/PowerSnail/">Github</a> <a class="icon-prefix mail" href="mailto:hj@powersnail.com">hj@powersnail.com</a>
      </nav>
      <div>
        © PowerSnail 2016
      </div>
    </footer>
  </body>
</html>
