<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; style-src 'self'; script-src 'self'; img-src 'self' https:">
    <meta name="author" content="PowerSnail">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#af3000">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="theme-color" content="#C93703">
    <title>
      Binary Search Tree implemented by C++ · SnailShell
    </title>
    <meta property="og:title" content="Binary Search Tree implemented by C++">
    <meta property="og:site_name" content="SnailShell">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://powersnail.com/2016/binary-search-tree/">
    <meta property="og:image" content="https://powersnail.com/icons/snail.svg">
    <link rel="canonical" href="https://powersnail.com/2016/binary-search-tree/">
    <link rel="stylesheet" href="/css/christmas.css">
    <link rel="prefetch" href="/images/front-cover.webp" as="image" crossorigin="">
    <link rel="preload" as="font" href="/fonts/crimson-text.woff2" type="font/woff2" crossorigin="">
  </head>
  <body>
    <div id="christmas">
      <div>
        🌨 🌨 🎅 🌨 🌨 🌨 🌨 🌨 🌨
      </div>
      <div>
        🌲🌲 Merry Christmas and Happy New Year! 🌲🌲
      </div>
    </div>
    <header>
      <a href="/">SnailShell</a>
      <nav>
        <a type="button" href="/posts/">Posts</a> <a type="button" href="/status/">Status</a> <a type="button" href="/about/">About</a>
      </nav>
      <link rel="stylesheet" href="/css/style.css">
    </header>
    <main>
      <article id="post-main">
        <h1>
          Binary Search Tree implemented by C++
        </h1>
        <hr>
        <div class="metadata">
          <time datetime="2016-02-27T00:00:00Z">27 Feb 2016</time> · 948 words · 5 minutes read
        </div>
        <p>
          This is a simple implementation of binary search tree implemented by C++. Here are the methods of my BST:
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Node</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BST</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BST</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">root</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Traversals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">inorder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">inorderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">inorderIter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">preOrder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">preOrderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">postOrder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">postOrderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Search Operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">minimum</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">successor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">predecessor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Element Operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre>
        </div>
        <p>
          I will talk about some of the implementations. The complete source file can be found in my <a href="https://github.com/PowerSnail/Algorithms-Practices">algorithm repository</a>. If you found any problem with the implementation, or anything that is worth adding to this, please leave a comment under this article or open an issue in the algorithm repository. This BST does not insert repeated element.
        </p>
        <h2 id="basic-idea">
          Basic Idea
        </h2>
        <p>
          Binary Search Tree is a basic data structure in computer science. It stores data, in my case some integers, into a tree-like structure.
        </p>
        <p>
          In a tree, there are nodes, which are the storage a piece of data and also connection to other nodes. A node can connect to its parent and its children. In other trees, there could be unlimited children, but for our case, a binary tree could have at most two children. Naturally, let’s call them left and right child respectively.
        </p>
        <p>
          <img src="/images/binarysearchtree.jpg" alt="Binary Search Tree" srcset="/images/binarysearchtree-400w.jpg 400w,/images/binarysearchtree-600w.jpg 600w,/images/binarysearchtree-800w.jpg 800w,/images/binarysearchtree-1000w.jpg 1000w,/images/binarysearchtree-1200w.jpg 1200w,/images/binarysearchtree.jpg 2445w" width="2445" height="2308">
        </p>
        <p>
          The top node is called root, and the nodes that do not have a child are called leaves. There is a <code>nil</code> sentinel node, which is not in the data structure but a <a href="#sentinelNode">useful element</a> in our program.
        </p>
        <h2 id="traversals">
          Traversals
        </h2>
        <p>
          The recursive in-order traversal is easy to implement:
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">inorderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderRec</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderRec</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre>
        </div>
        <p>
          The iterative algorithm is slightly more complex. It involves two pointers, marking the current and previous position of our traversal. Although this is not recursive, we could still think of it using an inductive reasoning. We first set the initial states to root and nil (who is the parent of root):
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span></span></span></code></pre>
        </div>
        <p>
          For an arbitrary iteration, there are three possibilities:
        </p>
        <ol>
          <li>
            <code>prev</code> is the parent of <code>x</code>. It means we have been going downwards in the tree, and both left branch and right branch of <code>x</code> has not yet been explored; then as in-order traversal requires, we go left from here.
          </li>
          <li>
            <code>prev</code> is the left child of <code>x</code>. This means we have just come back from the left branch, implying that the left is already printed. Now we have to print <code>x</code> itself and going to the right.
          </li>
          <li>
            <code>prev</code> is the right child of <code>x</code>. This means we have printed everything in the subtree rooted at <code>x</code>, and should now go up.
          </li>
        </ol>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>
                  <code>prev</code> pointing at
                </th>
                <th>
                  printed subtree
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <code>-&gt; parent</code>
                </td>
                <td>
                  none
                </td>
              </tr>
              <tr>
                <td>
                  <code>-&gt; left</code>
                </td>
                <td>
                  rooted at <code>left</code>
                </td>
              </tr>
              <tr>
                <td>
                  <code>-&gt; right</code>
                </td>
                <td>
                  rooted at <code>x</code>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>
          The trick here is to 1) progress the printing and 2) ensure that at the end of each iteration, the <em>invariant</em> is preserved, i.e. the situation falls into one of the situations.
        </p>
        <h4 id="prev-pointing-at-parent">
          <code>prev</code> Pointing at Parent
        </h4>
        <p>
          Nothing has been printed, so we go to left directly;
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">;</span></span></span></code></pre>
        </div>
        <p>
          We need to consider the case where <code>left</code> is nil, but this is easy because we can just throw <code>prev</code> to left. This works because if we examine the <em>loop invariant</em>, now the tree complies with the second situation.
        </p>
        <h4 id="prev-pointing-at-left">
          <code>prev</code> Pointing at left
        </h4>
        <p>
          Left tree is already printed (we consider <code>nil</code> as printed), so we try to go right. Don’t forget to first print out <code>x</code> before entering right.
        </p>
        <p>
          There is a slight complication if <code>x</code> is a leaf, as both children are <code>nil</code>. We would not be able to know whether we have come back from left or right! The traversal will circle around at <code>x</code> forever.
        </p>
        <p>
          <img src="/images/fromlefttoright.jpg" alt="From Left to Right" srcset="/images/fromlefttoright-400w.jpg 400w,/images/fromlefttoright-600w.jpg 600w,/images/fromlefttoright-800w.jpg 800w,/images/fromlefttoright-1000w.jpg 1000w,/images/fromlefttoright-1200w.jpg 1200w,/images/fromlefttoright.jpg 2441w" width="2441" height="2067" loading="lazy"> {:width=“36px”}.
        </p>
        <p>
          The solution is that we never come from right at a leaf node. When we reach a leaf node from its left, we directly move upwards.
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">==</span> <span class="n">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>  <span class="c1">// right branch is nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre>
        </div>
        <h4 id="prev-pointing-at-right">
          <code>prev</code> Pointing at Right
        </h4>
        <p>
          We know <code>x</code> subtree is all printed, so all we need to do is to move <code>x</code> upwards.
        </p>
        <div class="highlight">
          <pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span></span></span></code></pre>
        </div>
        <h2 id="insertion">
          Insertion
        </h2>
        <p>
          Insertion always occur at leaf in a BST. Generally, we need to 1) find a proper leaf as the parent of our new node and 2) insert it into the proper child of the leaf.
        </p>
        <h2 id="a-idsentinelnodea-sentinel-node">
          <a id="sentinelNode"></a> Sentinel Node
        </h2>
        <p>
          How is a sentinel node useful? There are several uses of it, and the most important one is to replace <code>NULL</code> for representing a non-existing element. It guards against null pointers.
        </p>
        <p>
          <code>NULL</code> is a very bad design from the very beginning, as it is passed into a function as <code>pointer type</code> but is not a <code>pointer</code> at all. Any attempt to call a member function will cause a crush. It is also hard to debug, especially when there are layers of function calls. You cannot dereference a null pointer in debugger; it points to 0x00000000, which has no useful information at all.
        </p>
        <p>
          A sentinel <code>nil</code> on the other hand is a legitimate <code>Node</code> object. It has all functions supported, and could be more useful for debugging. Debugging-wise, it is printable and assignable.
        </p>
        <p>
          It is also used as the parent of <code>root</code> in our tree. This eliminates the difference between an empty tree and non-empty tree, so insertion and removal of <code>root</code> could be carried out without an extra conditional branch.
        </p>
        <h2 id="codes">
          Codes
        </h2><!--  -->
        <div>
          <a class="tag" href="/tags/computer-science">#computer science</a> <a class="tag" href="/tags/algorithms">#Algorithms</a> <a class="tag" href="/tags/bst">#BST</a> <a class="tag" href="/tags/data-structure">#Data Structure</a>
        </div>
        <footer>
          <p>
            This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer">CC BY-SA 4.0 <img class="inline-icon" alt="Icons for Creative Commons's BY-SA 4.0 license" src="/images/cc-all.svg" loading="lazy"></a>
          </p>
        </footer>
      </article>
    </main>
    <footer>
      <nav>
        <a href="/index.xml" class="social"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="20" height="20" viewbox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <circle cx="5" cy="19" r="1"></circle>
        <path d="M4 4a16 16 0 0 1 16 16"></path>
        <path d="M4 11a9 9 0 0 1 9 9"></path></svg> RSS</a> <a href="https://github.com/PowerSnail/" class="social"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="20" height="20" viewbox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg> Github</a> <a href="mailto:hj@powersnail.com" class="social"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="20" height="20" viewbox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <rect x="3" y="5" width="18" height="14" rx="2"></rect>
        <polyline points="3 7 12 13 21 7"></polyline></svg> hj@powersnail.com</a> <a rel="me" href="https://c.im/@powersnail" class="social"><svg width="20" height="20" viewbox="0 0 74 79" fill="currentcolor" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M73.7014 17.4323C72.5616 9.05152 65.1774 2.4469 56.424 1.1671C54.9472 0.950843 49.3518 0.163818 36.3901 0.163818H36.2933C23.3281 0.163818 20.5465 0.950843 19.0697 1.1671C10.56 2.41145 2.78877 8.34604 0.903306 16.826C-0.00357854 21.0022 -0.100361 25.6322 0.068112 29.8793C0.308275 35.9699 0.354874 42.0498 0.91406 48.1156C1.30064 52.1448 1.97502 56.1419 2.93215 60.0769C4.72441 67.3445 11.9795 73.3925 19.0876 75.86C26.6979 78.4332 34.8821 78.8603 42.724 77.0937C43.5866 76.8952 44.4398 76.6647 45.2833 76.4024C47.1867 75.8033 49.4199 75.1332 51.0616 73.9562C51.0841 73.9397 51.1026 73.9184 51.1156 73.8938C51.1286 73.8693 51.1359 73.8421 51.1368 73.8144V67.9366C51.1364 67.9107 51.1302 67.8852 51.1186 67.862C51.1069 67.8388 51.0902 67.8184 51.0695 67.8025C51.0489 67.7865 51.0249 67.7753 50.9994 67.7696C50.9738 67.764 50.9473 67.7641 50.9218 67.7699C45.8976 68.9569 40.7491 69.5519 35.5836 69.5425C26.694 69.5425 24.3031 65.3699 23.6184 63.6327C23.0681 62.1314 22.7186 60.5654 22.5789 58.9744C22.5775 58.9477 22.5825 58.921 22.5934 58.8965C22.6043 58.8721 22.621 58.8505 22.6419 58.8336C22.6629 58.8167 22.6876 58.8049 22.714 58.7992C22.7404 58.7934 22.7678 58.794 22.794 58.8007C27.7345 59.9796 32.799 60.5746 37.8813 60.5733C39.1036 60.5733 40.3223 60.5733 41.5447 60.5414C46.6562 60.3996 52.0437 60.1408 57.0728 59.1694C57.1983 59.1446 57.3237 59.1233 57.4313 59.0914C65.3638 57.5847 72.9128 52.8555 73.6799 40.8799C73.7086 40.4084 73.7803 35.9415 73.7803 35.4523C73.7839 33.7896 74.3216 23.6576 73.7014 17.4323ZM61.4925 47.3144H53.1514V27.107C53.1514 22.8528 51.3591 20.6832 47.7136 20.6832C43.7061 20.6832 41.6988 23.2499 41.6988 28.3194V39.3803H33.4078V28.3194C33.4078 23.2499 31.3969 20.6832 27.3894 20.6832C23.7654 20.6832 21.9552 22.8528 21.9516 27.107V47.3144H13.6176V26.4937C13.6176 22.2395 14.7157 18.8598 16.9118 16.3545C19.1772 13.8552 22.1488 12.5719 25.8373 12.5719C30.1064 12.5719 33.3325 14.1955 35.4832 17.4394L37.5587 20.8853L39.6377 17.4394C41.7884 14.1955 45.0145 12.5719 49.2765 12.5719C52.9614 12.5719 55.9329 13.8552 58.2055 16.3545C60.4017 18.8574 61.4997 22.2371 61.4997 26.4937L61.4925 47.3144Z" fill="inherit"></path></svg> @powersnail@c.im</a>
      </nav>
      <div>
        © PowerSnail 2016
      </div>
    </footer>
  </body>
</html>
