<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">    
<meta name="viewport" content="width=device-width, initial-scale=1.0">






<meta name="author" content="PowerSnail">

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<meta name="theme-color" content="#bd1b37">

<title>Binary Search Tree implemented by C&#43;&#43; · SnailShell</title>

<meta property="og:title" content="Binary Search Tree implemented by C&#43;&#43;" />
<meta property="og:site_name" content="SnailShell" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://powersnail.com/2016/binary-search-tree/" />


  <meta property="og:image" content="https://powersnail.com/icons/snail.svg" />




<link rel="canonical" href="https://powersnail.com/2016/binary-search-tree/"/>




  <link id="main-css" rel="stylesheet" href="/css/style.css">





  </head>
<body>
  
  
    <div
  style="
    height: 50px;
    width: 100%;
    grid-column: 1/-1;
    grid-template-columns: subgrid;
    background-color: #f57029ff;
    display: grid;
  "
>
  <div style="grid-column: 3/-3; position: relative">
    <img
      src="/images/halloween.webp"
      width="256px"
      height="48px"
      style="position: absolute; left: 0; top: 0; max-width: 100%; height: auto;"
    />
  </div>
</div>


  
  
  <header>
  <article>
    <nav class="site-nav">
      <a href="/" class="site-title">
        <span class="site-title-text">Snail's Shell</span>
      </a>
      <div class="site-title-fill"></div>
      <a href="/posts/" class="nav-link">
        Posts
      </a>
      <details>
        <summary><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="icon" width="16" height="16">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
</svg>

More
        </summary>
        <div class="site-title-more">
          <a href="/index.xml" class="nav-link">
            RSS
          </a>
          <a href="/about/" class="nav-link">
            About
          </a>
          <a href="/sheet-music/" class="nav-link">
            Sheet Music
          </a>
          <a href="/stats/" class="nav-link">
            Blog Stats
          </a>
          <a href="/cat_dot/" class="nav-link">
            Moving Red Dot for Cat
          </a>
          <a href="/game_of_life/" class="nav-link">
            Game of Life
          </a>
        </div>
      </details>
    </nav>
  </article>
</header>

  <main>
<article id="post-main"><h1>
  Binary Search Tree implemented by C++
  

</h1>



<div class="metadata">
    <time datetime="2016-02-27T00:00:00Z">27 Feb 2016</time>
    ·
    958 words
    ·
    5 minutes read
</div>
<hr />

<p>This is a simple implementation of binary search tree implemented by C++. Here are the methods of my BST:</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Node</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BST</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span> <span class="o">*</span><span class="n">nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BST</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">root</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Traversals
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">inorder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">inorderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">inorderIter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">preOrder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">preOrderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">postOrder</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">postOrderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Search Operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">minimum</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">successor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">*</span> <span class="nf">predecessor</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Element Operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span></span></span></code></pre></div><p>I will talk about some of the implementations. The complete source file can be found in my <a href="https://github.com/PowerSnail/Algorithms-Practices">algorithm repository</a>. If you found any problem with the implementation, or anything that is worth adding to this, please leave a comment under this article or open an issue in the algorithm repository. This BST does not insert repeated element.</p>
<h2 id="basic-idea">
  Basic Idea
  <a href="#basic-idea"><small>##</small></a>
</h2>
<p>Binary Search Tree is a basic data structure in computer science. It stores data, in my case some integers, into a tree-like structure.</p>
<p>In a tree, there are nodes, which are the storage a piece of data and also connection to other nodes. A node can connect to its parent and its children. In other trees, there could be unlimited children, but for our case, a binary tree could have at most two children. Naturally, let&rsquo;s call them left and right child respectively.</p>
<figure>
    <img
    src="/images/binarysearchtree.jpg" alt="Binary Search Tree"srcset="/images/binarysearchtree-400w.jpg 400w,/images/binarysearchtree-600w.jpg 600w,/images/binarysearchtree-800w.jpg 800w,/images/binarysearchtree-1000w.jpg 1000w,/images/binarysearchtree-1200w.jpg 1200w,/images/binarysearchtree.jpg 2445w" width="2445"  height="2308" >

    <figcaption></figcaption>
  </figure><p>The top node is called root, and the nodes that do not have a child are called leaves. There is a <code>nil</code> sentinel node, which is not in the data structure but a <a href="#sentinelNode">useful element</a> in our program.</p>
<h2 id="traversals">
  Traversals
  <a href="#traversals"><small>##</small></a>
</h2>
<p>The recursive in-order traversal is easy to implement:</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">inorderRec</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderRec</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">node</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">inorderRec</span><span class="p">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>The iterative algorithm is slightly more complex. It involves two pointers, marking the current and previous position of our traversal. Although this is not recursive, we could still think of it using an inductive reasoning. We first set the initial states to root and nil (who is the parent of root):</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span></span></span></code></pre></div><p>For an arbitrary iteration, there are three possibilities:</p>
<ol>
<li><code>prev</code> is the parent of <code>x</code>. It means we have been going downwards in the tree, and both left branch and right branch of <code>x</code> has not yet been explored; then as in-order traversal requires, we go left from here.</li>
<li><code>prev</code> is the left child of <code>x</code>. This means we have just come back from the left branch, implying that the left is already printed. Now we have to print <code>x</code> itself and going to the right.</li>
<li><code>prev</code> is the right child of <code>x</code>. This means we have printed everything in the subtree rooted at <code>x</code>, and should now go up.</li>
</ol>
<div class="table-wrapper"> <table>
<thead>
<tr>
<th><code>prev</code> pointing at</th>
<th>printed subtree</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-&gt; parent</code></td>
<td>none</td>
</tr>
<tr>
<td><code>-&gt; left</code></td>
<td>rooted at <code>left</code></td>
</tr>
<tr>
<td><code>-&gt; right</code></td>
<td>rooted at <code>x</code></td>
</tr>
</tbody>
</table> </div>
<p>The trick here is to 1) progress the printing and 2) ensure that at the end of each iteration, the <em>invariant</em> is preserved, i.e. the situation falls into one of the situations.</p>
<h4 id="prev-pointing-at-parent">
  <code>prev</code> Pointing at Parent
  <a href="#prev-pointing-at-parent"><small>####</small></a>
</h4>
<p>Nothing has been printed, so we go to left directly;</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">left</span><span class="p">;</span></span></span></code></pre></div><p>We need to consider the case where <code>left</code> is nil, but this is easy because we can just throw <code>prev</code> to left. This works because if we examine the <em>loop invariant</em>, now the tree complies with the second situation.</p>
<h4 id="prev-pointing-at-left">
  <code>prev</code> Pointing at left
  <a href="#prev-pointing-at-left"><small>####</small></a>
</h4>
<p>Left tree is already printed (we consider <code>nil</code> as printed), so we try to go right. Don&rsquo;t forget to first print out <code>x</code> before entering right.</p>
<p>There is a slight complication if <code>x</code> is a leaf, as both children are <code>nil</code>. We would not be able to know whether we have come back from left or right! The traversal will circle around at <code>x</code> forever.</p>
<p><img
    src="/images/fromlefttoright.jpg" alt="From Left to Right"srcset="/images/fromlefttoright-400w.jpg 400w,/images/fromlefttoright-600w.jpg 600w,/images/fromlefttoright-800w.jpg 800w,/images/fromlefttoright-1000w.jpg 1000w,/images/fromlefttoright-1200w.jpg 1200w,/images/fromlefttoright.jpg 2441w" width="2441"  height="2067" loading="lazy">
{:width=&ldquo;36px&rdquo;}.</p>
<p>The solution is that we never come from right at a leaf node. When we reach a leaf node from its left, we directly move upwards.</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">right</span> <span class="o">==</span> <span class="n">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>  <span class="c1">// right branch is nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><h4 id="prev-pointing-at-right">
  <code>prev</code> Pointing at Right
  <a href="#prev-pointing-at-right"><small>####</small></a>
</h4>
<p>We know <code>x</code> subtree is all printed, so all we need to do is to move <code>x</code> upwards.</p>
<div class="highlight"><pre  class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">prev</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">parent</span><span class="p">;</span></span></span></code></pre></div><h2 id="insertion">
  Insertion
  <a href="#insertion"><small>##</small></a>
</h2>
<p>Insertion always occur at leaf in a BST. Generally, we need to 1) find a proper leaf as the parent of our new node and 2) insert it into the proper child of the leaf.</p>
<h2 id="a-idsentinelnodea-sentinel-node">
  <a id="sentinelNode"></a> Sentinel Node
  <a href="#a-idsentinelnodea-sentinel-node"><small>##</small></a>
</h2>
<p>How is a sentinel node useful? There are several uses of it, and the most important one is to replace <code>NULL</code> for representing a non-existing element. It guards against null pointers.</p>
<p><code>NULL</code> is a very bad design from the very beginning, as it is passed into a function as <code>pointer type</code> but is not a <code>pointer</code> at all. Any attempt to call a member function will cause a crush. It is also hard to debug, especially when there are layers of function calls. You cannot dereference a null pointer in debugger; it points to 0x00000000, which has no useful information at all.</p>
<p>A sentinel <code>nil</code> on the other hand is a legitimate <code>Node</code> object. It has all functions supported, and could be more useful for debugging. Debugging-wise, it is printable and assignable.</p>
<p>It is also used as the parent of <code>root</code> in our tree. This eliminates the difference between an empty tree and non-empty tree, so insertion and removal of <code>root</code> could be carried out without an extra conditional branch.</p>
<h2 id="codes">
  Codes
  <a href="#codes"><small>##</small></a>
</h2>
<!--  -->


  


  <footer>
    

    <section class="footer-meta">
      
      <p>
        
        <svg
          aria-label="tags"
          class="icon"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="currentColor"
          width="16"
          height="16"
        >
          <path
            fill-rule="evenodd"
            d="M5.25 2.25a3 3 0 00-3 3v4.318a3 3 0 00.879 2.121l9.58 9.581c.92.92 2.39 1.186 3.548.428a18.849 18.849 0 005.441-5.44c.758-1.16.492-2.629-.428-3.548l-9.58-9.581a3 3 0 00-2.122-.879H5.25zM6.375 7.5a1.125 1.125 0 100-2.25 1.125 1.125 0 000 2.25z"
            clip-rule="evenodd"
          />
        </svg>
           <a href="/tags/computer-science"><code>computer science</code></a>, <a href="/tags/algorithms"><code>Algorithms</code></a>, <a href="/tags/bst"><code>BST</code></a>, <a href="/tags/data-structure"><code>Data Structure</code></a>
      </p>
      
    </section>

    <section><p>
        Leave a comment via email: 
        <a href="mailto:comment.2016.binary-search-tree@powersnail.com">comment.2016.binary-search-tree@powersnail.com</a>. 
      </p>
    </section>
  </footer>
</article>


  </main><footer>
  <article><div>© PowerSnail 2016</div>
  </article>
</footer>

</body>
</html>
