<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-security-policy content="default-src 'self'; img-src 'self' https://snailshell.goatcounter.com/count https://mirrors.creativecommons.org/; style-src 'self' 'unsafe-inline'"><meta http-equiv=content-type content="text/html;charset=utf-8;x-content-type-options=nosniff"><meta name=author content="PowerSnail"><meta name=generator content="Hugo 0.101.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#af3000><meta name=msapplication-TileColor content="#000000"><meta name=theme-color content="#af3000"><title>Binary Search Tree implemented by C++ Â· SnailShell</title><link rel=stylesheet href=https://powersnail.com/style.css><link rel=canonical href=https://powersnail.com/2016/binary-search-tree/></head><body><header><div class=site-title><a href=https://powersnail.com/>SnailShell</a></div><nav><a type=button href=/posts/>Posts</a>
<a type=button href=/status/>Status</a>
<a type=button href=/about/>About</a></nav></header><img class=goatcounter alt width=1 height=1 src="https://snailshell.goatcounter.com/count?p=%2f2016%2fbinary-search-tree%2f&t=Binary%20Search%20Tree%20implemented%20by%20C%2b%2b"><main><article><header><h1>Binary Search Tree implemented by C++</h1><hr><div id=metadata><details><summary class="icon-prefix tags">Tags</summary><div class=tag-list><a class=tag href=/tags/computer-science>computer science</a> <a class=tag href=/tags/algorithms>Algorithms</a> <a class=tag href=/tags/bst>BST</a> <a class=tag href=/tags/data-structure>Data Structure</a></div></details><span class="icon-prefix calendar-event">2016-02-27</span>
<span class="icon-prefix calculator">1020 words</span>
<span class="icon-prefix clock">5 minutes read</span></div></header><p>This is a simple implementation of binary search tree implemented by C++. Here are the methods of my BST:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>left</span><span class=p>,</span> <span class=o>*</span><span class=n>right</span><span class=p>,</span> <span class=o>*</span><span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BST</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span> <span class=o>*</span><span class=n>nil</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>BST</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=nf>root</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Traversals
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>inorder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>inorderRec</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>inorderIter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>preOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>preOrderRec</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>postOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>postOrderRec</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Search Operations
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span><span class=o>*</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=nf>minimum</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=nf>maximum</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=nf>successor</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>*</span> <span class=nf>predecessor</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Element Operation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>insert</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>remove</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>remove</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>transplant</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span><span class=p>,</span> <span class=n>Node</span><span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>empty</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>I will talk about some of the implementations. The complete source file can be found in my <a href=https://github.com/PowerSnail/Algorithms-Practices>algorithm repository</a>. If you found any problem with the implementation, or anything that is worth adding to this, please leave a comment under this article or open an issue in the algorithm repository. This BST does not insert repeated element.</p><h2 id=basic-idea>Basic Idea</h2><p>Binary Search Tree is a basic data structure in computer science. It stores data, in my case some integers, into a tree-like structure.</p><p>In a tree, there are nodes, which are the storage a piece of data and also connection to other nodes. A node can connect to its parent and its children. In other trees, there could be unlimited children, but for our case, a binary tree could have at most two children. Naturally, let&rsquo;s call them left and right child respectively.</p><p><img src=/images/binarysearchtree.jpg alt="Binary Search Tree" width=2445 height=2308></p><p>The top node is called root, and the nodes that do not have a child are called leaves. There is a <code>nil</code> sentinel node, which is not in the data structure but a <a href=#sentinelNode>useful element</a> in our program.</p><h2 id=traversals>Traversals</h2><p>The recursive in-order traversal is easy to implement:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>BST</span><span class=o>::</span><span class=n>inorderRec</span><span class=p>(</span><span class=n>Node</span><span class=o>*</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>!=</span> <span class=n>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>inorderRec</span><span class=p>(</span><span class=n>node</span> <span class=o>-&gt;</span> <span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>node</span> <span class=o>-&gt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>inorderRec</span><span class=p>(</span><span class=n>node</span> <span class=o>-&gt;</span> <span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>The iterative algorithm is slightly more complex. It involves two pointers, marking the current and previous position of our traversal. Although this is not recursive, we could still think of it using an inductive reasoning. We first set the initial states to root and nil (who is the parent of root):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>x</span> <span class=o>=</span> <span class=n>root</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>prev</span> <span class=o>=</span> <span class=n>nil</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>For an arbitrary iteration, there are three possibilities:</p><ol><li><code>prev</code> is the parent of <code>x</code>. It means we have been going downwards in the tree, and both left branch and right branch of <code>x</code> has not yet been explored; then as in-order traversal requires, we go left from here.</li><li><code>prev</code> is the left child of <code>x</code>. This means we have just come back from the left branch, implying that the left is already printed. Now we have to print <code>x</code> itself and going to the right.</li><li><code>prev</code> is the right child of <code>x</code>. This means we have printed everything in the subtree rooted at <code>x</code>, and should now go up.</li></ol><div class=table-wrapper><table><thead><tr><th><code>prev</code> pointing at</th><th>printed subtree</th></tr></thead><tbody><tr><td><code>-> parent</code></td><td>none</td></tr><tr><td><code>-> left</code></td><td>rooted at <code>left</code></td></tr><tr><td><code>-> right</code></td><td>rooted at <code>x</code></td></tr></tbody></table></div><p>The trick here is to 1) progress the printing and 2) ensure that at the end of each iteration, the <em>invariant</em> is preserved, i.e. the situation falls into one of the situations.</p><h4 id=prev-pointing-at-parent><code>prev</code> Pointing at Parent</h4><p>Nothing has been printed, so we go to left directly;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>prev</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>left</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>We need to consider the case where <code>left</code> is nil, but this is easy because we can just throw <code>prev</code> to left. This works because if we examine the <em>loop invariant</em>, now the tree complies with the second situation.</p><h4 id=prev-pointing-at-left><code>prev</code> Pointing at left</h4><p>Left tree is already printed (we consider <code>nil</code> as printed), so we try to go right. Don&rsquo;t forget to first print out <code>x</code> before entering right.</p><p>There is a slight complication if <code>x</code> is a leaf, as both children are <code>nil</code>. We would not be able to know whether we have come back from left or right! The traversal will circle around at <code>x</code> forever.</p><p><img src=/images/fromlefttoright.jpg alt="From Left to Right" width=2441 height=2067>{:width=&ldquo;36px&rdquo;}.</p><p>The solution is that we never come from right at a leaf node. When we reach a leaf node from its left, we directly move upwards.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>right</span> <span class=o>==</span> <span class=n>nil</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>  <span class=c1>// right branch is nil
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>prev</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=prev-pointing-at-right><code>prev</code> Pointing at Right</h4><p>We know <code>x</code> subtree is all printed, so all we need to do is to move <code>x</code> upwards.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>prev</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-&gt;</span> <span class=n>parent</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><h2 id=insertion>Insertion</h2><p>Insertion always occur at leaf in a BST. Generally, we need to 1) find a proper leaf as the parent of our new node and 2) insert it into the proper child of the leaf.</p><h2 id=a-namesentinelnodea-sentinel-node><a name=sentinelNode></a> Sentinel Node</h2><p>How is a sentinel node useful? There are several uses of it, and the most important one is to replace <code>NULL</code> for representing a non-existing element. It guards against null pointers.</p><p><code>NULL</code> is a very bad design from the very beginning, as it is passed into a function as <code>pointer type</code> but is not a <code>pointer</code> at all. Any attempt to call a member function will cause a crush. It is also hard to debug, especially when there are layers of function calls. You cannot dereference a null pointer in debugger; it points to 0x00000000, which has no useful information at all.</p><p>A sentinel <code>nil</code> on the other hand is a legitimate <code>Node</code> object. It has all functions supported, and could be more useful for debugging. Debugging-wise, it is printable and assignable.</p><p>It is also used as the parent of <code>root</code> in our tree. This eliminates the difference between an empty tree and non-empty tree, so insertion and removal of <code>root</code> could be carried out without an extra conditional branch.</p><h2 id=codes>Codes</h2><footer><p id=cc>This work is licensed under
<a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0
<img alt="Creative Commons License CC BY-SA 4.0" src=/images/cc-all.svg style=height:1.2em;width:auto loading=lazy width=29.633333 height=10.583333></a></p></footer></article></main><footer><nav><a href=https://gohugo.io/>This blog is Powered by Hugo</a>
<a class="icon-prefix rss" href=/index.xml class=social-rss>RSS</a>
<a class="icon-prefix brand-github" href=https://github.com/PowerSnail/>Github</a>
<a class="icon-prefix mail" href=mailto:hj@powersnail.com>hj@powersnail.com</a></nav><div>Copyright @ PowerSnail 2016-2022</div></footer></body></html>