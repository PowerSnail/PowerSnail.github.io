<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-security-policy content="default-src 'self'; img-src 'self' https://snailshell.goatcounter.com/count https://mirrors.creativecommons.org/; style-src 'self' 'unsafe-inline'"><meta http-equiv=content-type content="text/html;charset=utf-8;x-content-type-options=nosniff"><meta name=author content="PowerSnail"><meta name=description content="some notes on Parsing Techniques A Practical Guide"><meta name=generator content="Hugo 0.101.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#af3000><meta name=msapplication-TileColor content="#000000"><meta name=theme-color content="#af3000"><title>Generative Grammar and Four Types of Grammars: Parsing Techniques Notes (1) · SnailShell</title><link rel=stylesheet href=https://powersnail.com/style.css><link rel=canonical href=https://powersnail.com/2016/parsing-techniques-notes01/></head><body><header><div id=site-title><a href=https://powersnail.com/>SnailShell</a></div><nav><a type=button href=/posts/>Posts</a>
<a type=button href=/status/>Status</a>
<a type=button href=/about/>About</a></nav></header><img class=goatcounter alt width=1 height=1 src="https://snailshell.goatcounter.com/count?p=%2f2016%2fparsing-techniques-notes01%2f&t=Generative%20Grammar%20and%20Four%20Types%20of%20Grammars%3a%20Parsing%20Techniques%20Notes%20%281%29"><main><article><header><h1>Generative Grammar and Four Types of Grammars: Parsing Techniques Notes (1)</h1><hr><div id=metadata><details><summary class="icon-prefix tags">Tags</summary><div class=tag-list><a class=tag href=/tags/computer-science>computer science</a> <a class=tag href=/tags/notes>notes</a> <a class=tag href=/tags/study>study</a> <a class=tag href=/tags/parsing>parsing</a></div></details><span class="icon-prefix calendar-event">2016-02-24</span>
<span class="icon-prefix calculator">546 words</span>
<span class="icon-prefix clock">3 minutes read</span></div></header><h2 id=generative-grammar>Generative Grammar</h2><p>There are several views of defining a language. The computer science and formal linguistics perspective:</p><div class=table-wrapper><table><thead><tr><th>terms</th><th>definition</th></tr></thead><tbody><tr><td>Language</td><td>a set of sentences</td></tr><tr><td>Sentence</td><td>a <strong>sequence</strong> of symbols</td></tr><tr><td>Alphabet</td><td>a set of all symbols</td></tr></tbody></table></div><p>The semantics - meaning - of a sentence is described by its tokens cooperating with its structure.</p><p>Grammar is the set of rules describing a language.
<strong>Generative Grammar</strong> is</p><ul><li>exact</li><li>fixed-sized</li></ul><h3 id=language-can-be-specified-by-infinite-bit-string>Language can be specified by infinite Bit-String</h3><p>Sorted Alphabet: $\Sigma$
Language $\Sigma^{* }$ contains all combinations of symbols in $\Sigma$</p><p>The order of sentences in $\Sigma^* $ follows that:</p><p><em>from length $l = 0$</em></p><ol><li>Enumerate all combinations that of length $l$</li><li>these combinations are listed according to alphabetical order (lexicographical sorting)</li><li>increment $l$ and repeat from 1.</li></ol><p>This will form an infinitely long sorted list. Every language composed by alphabet $\Sigma$ can be identified by choosing from $\Sigma^* $. If we encode this by binary representation, 0 → not including, 1 → including, we can create an infinitely long bit string that indicates every sentence the language contains.</p><blockquote><p>For example:
Language $L = 010010110&mldr;$</p></blockquote><h3 id=formal-grammar>Formal Grammar</h3><p>Recipe of replacing symbols:</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>Name  -&gt; tom | dick | harry // Name may be replaced by tom, dick or harry
</span></span><span class=line><span class=cl>...</span></span></code></pre></div><p>A grammar is a <em>4-tuple</em> $(V_N, V_T, R, S)$:</p><ul><li>$V_N$ non-terminals, $V_T$ terminals are finite sets of symbols</li><li>$V_N \cap V_T = \varnothing$ terminals and non-terminals cannot have common symbols</li><li>$R$ is the set of rules, a set that contains ordered pairs: ${(P, Q) \mid P\in (V_N\cup V_T)^+ \land Q\in (V_N \cup V_T)^* }$</li><li>$S$ is the start symbol, $S\in V_N$</li></ul><h2 id=four-types-of-grammars>Four types of Grammars</h2><h3 id=type-0-phrase-structure-grammar-ps-grammar>Type 0: Phrase Structure Grammar (PS Grammar)</h3><p>Most freedom. Follows <em>4-tuple</em> $(V_N, V_T, R, S)$, without further restriction.
Represented as <code>Directed Acyclic Graph</code>: No cycle exists</p><h3 id=type-1-context-sensitive-grammar-cs-grammar>Type 1: Context-Sensitive Grammar (CS Grammar)</h3><p>There are two equivalent definitions: <code>Monotonic</code> and <code>Context-Sensitive</code>.
Can be represented by a DAG, similar to PS Grammar.</p><h4 id=monotonic>Monotonic</h4><p>For each rule, left-hand side has more or equal number of symbols to right-hand side.</p><h4 id=context-sensitive>Context-Sensitive</h4><p>Every rule is context-sensitive.</p><ul><li>Left-hand side contains only one symbol to be changed in the right-hand side.</li></ul><h3 id=type-2-context-free-grammar-cf-grammar>Type 2: Context-Free Grammar (CF Grammar)</h3><p>LHS could only contain one non-terminal symbol. (Thus not related to neighboring symbols).
Represented by a tree, as branches of a node is not relevant to other nodes.</p><p>The generative power of CF Grammar comes from two operations:</p><ul><li>Concatenation</li><li>Choice (choosing from one of the alternatives in the RHS)</li></ul><p><code>NT -> tom | NT dick | ...</code></p><h3 id=type-3-regular-grammar>Type 3: Regular Grammar</h3><p>Mostly referring to <code>right regular grammar</code>.
Each rule could only contain one non-terminal, as the rightmost item.
Represented by a list, because each sentential has only one replaceable item (non-terminal), or in a production chain.</p><p>All regular grammar can be expressed in a regular expression, which sufficiently equal to all rules in the grammar.</p><p>Regular Expression Notation Styles:</p><div class=table-wrapper><table><thead><tr><th>Notation</th><th>Description</th></tr></thead><tbody><tr><td>$^{+ }$</td><td>One or more instances of the left-adjacent item</td></tr><tr><td>$^{* }$</td><td>Zero or more instances of the left-adjacent item</td></tr><tr><td>$^{? }$</td><td>Zero or one instance of the left-adjacent item</td></tr><tr><td>$[abc]$</td><td>Choosing one from $(a, b, c)$, i.e., $(a\mid b\mid c)$</td></tr></tbody></table></div><p>Example:</p><p>$S_S\to(([tdh],)^{* }[tdh] & )^{? }[tdh]$</p><h3 id=type-4-finite-choice-grammar-fc-grammar>Type 4: Finite Choice Grammar (FC Grammar)</h3><p>Each rule could have only terminals in right-hand side.
Very limited expressive power.</p><footer><p id=cc>This work is licensed under
<a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0
<img alt="Creative Commons License CC BY-SA 4.0" src=/images/cc-all.svg style=height:1.4em;width:auto loading=lazy width=29.633333 height=10.583333></a></p></footer></article></main><footer><nav><a class="icon-prefix rss" href=/index.xml class=social-rss>RSS</a>
<a class="icon-prefix brand-github" href=https://github.com/PowerSnail/>Github</a>
<a class="icon-prefix mail" href=mailto:hj@powersnail.com>hj@powersnail.com</a></nav><div>© PowerSnail 2016</div></footer></body></html>