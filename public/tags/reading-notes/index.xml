<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>reading notes on SnailShell</title><link>https://powersnail.com/tags/reading-notes/</link><description>Recent content in reading notes on SnailShell</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright @ PowerSnail 2016-2022</copyright><lastBuildDate>Tue, 15 Nov 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://powersnail.com/tags/reading-notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Exceptional Control Flow</title><link>https://powersnail.com/2016/control-flow-exception/</link><pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate><guid>https://powersnail.com/2016/control-flow-exception/</guid><description>&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>A processor accesses a sequence of instructions when it operates. The transition from one to the next, is called &lt;em>control transfer&lt;/em>. The sequence of transfers is called &lt;em>control flow&lt;/em>. The control flow is smooth when the transitions are always to the adjacent address. Operations such as &lt;code>jump&lt;/code>, &lt;code>call&lt;/code>, etc. will cause the control flow to be abrupt.&lt;/p>
&lt;p>There are other situations where the control flow is abruptly changed. For example, hardware timer, network packet arrival, etc. are events that have to be dealt with but not necessarily a part of the execution of the program. The system will likely deal with such situations with &lt;em>exceptional control flow&lt;/em> (ECF), a disruption to the control flow.&lt;/p>
&lt;ul>
&lt;li>Application Level ECF: inter-process &lt;em>signal&lt;/em>&lt;/li>
&lt;li>OS kernel Level ECF: context switches&lt;/li>
&lt;/ul>
&lt;h2 id="exceptions">Exceptions&lt;/h2>
&lt;h3 id="definition">Definition&lt;/h3>
&lt;p>An &lt;em>exception&lt;/em> is an abrupt change in the control flow in response to some change in the processor&amp;rsquo;s state.&lt;/p>
&lt;p>An &lt;em>event&lt;/em> is a change in the processor&amp;rsquo;s state.&lt;/p>
&lt;h3 id="exception-happening">Exception Happening&lt;/h3>
&lt;p>When the application is executing instruction $I_{curr}$, there is an event occurred.&lt;/p>
&lt;p>The event could be either caused by the instruction just occurred, or completely unrelated to the application. The processor will look up the &lt;em>exception table&lt;/em>, and make a procedure call to the &lt;em>exception handler&lt;/em>, which will process the particular kind of event. Then, depending on the event, three things can occur:&lt;/p>
&lt;ol>
&lt;li>The handler returns, to $I_{curr}$&lt;/li>
&lt;li>The handler returns, to $I_{next}$&lt;/li>
&lt;li>The handler aborts the program&lt;/li>
&lt;/ol>
&lt;h3 id="exception-handling">Exception Handling&lt;/h3>
&lt;p>The handling of exception involves both hardware and software.&lt;/p>
&lt;p>Each type of exception is assigned an integer &lt;em>exception number&lt;/em>, assigned by:&lt;/p>
&lt;ul>
&lt;li>The designer of the processor
&lt;ul>
&lt;li>divide by zero&lt;/li>
&lt;li>page faults&lt;/li>
&lt;li>memory access violations&lt;/li>
&lt;li>break-points&lt;/li>
&lt;li>arithmetic overflows&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The OS kernel
&lt;ul>
&lt;li>system calls&lt;/li>
&lt;li>signals from external I/O devices&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>At &lt;strong>Boot time&lt;/strong>, the OS creates the exception table, mapping each exception number to the address of the exception handler for the particular type of exception.&lt;/p>
&lt;p>The table&amp;rsquo;s base address is contained in a CPU register, &lt;em>exception table base register&lt;/em>.&lt;/p>
&lt;p>At &lt;strong>Run time&lt;/strong>, the processor detects the event, and determines the exception number $k$. Then it makes an indirect procedure call through the address in table[$k$].&lt;/p>
&lt;p>The procedure call is accompanied by a few operations:&lt;/p>
&lt;ul>
&lt;li>The processor pushes the address of $I_{curr}$ or $I_{next}$ on to the &lt;strong>kernel stack&lt;/strong>&lt;/li>
&lt;li>the control is transferred to the kernel, which means the exception handlers run in &lt;strong>kernel mode&lt;/strong>, that they have access to all system resources.&lt;/li>
&lt;/ul>
&lt;p>The return is a special operation &lt;code>return from interrupt&lt;/code>, which restores kernel mode to user mode.&lt;/p>
&lt;h3 id="class-of-exceptions">Class of Exceptions&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Class&lt;/th>
&lt;th>Cause&lt;/th>
&lt;th>Async/Sync&lt;/th>
&lt;th>Return behavior&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Interrupt&lt;/td>
&lt;td>Signal from I/O device&lt;/td>
&lt;td>Async&lt;/td>
&lt;td>Always returns to next instruction&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Trap&lt;/td>
&lt;td>Intentional exception&lt;/td>
&lt;td>Sync&lt;/td>
&lt;td>Always returns to next instruction&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Fault&lt;/td>
&lt;td>Potentially recoverable error&lt;/td>
&lt;td>Sync&lt;/td>
&lt;td>Might return to current instruction&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Abort&lt;/td>
&lt;td>Nonrecoverable error&lt;/td>
&lt;td>Sync&lt;/td>
&lt;td>Never returns&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Table 1: Classes of Exceptions &lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;em>Async&lt;/em>: means that the event (IO Interrupt) is not caused by execution of any instruction, but rather an asynchronous signal that an external IO device sends to the processor.&lt;/p>
&lt;h4 id="interrupt-handling">Interrupt Handling&lt;/h4>
&lt;p>The handling of interrupt runs independent of the program. It is not caused by, has no impact on the current program. The processor notices the interrupt pin is set, and jumps to the interrupt handler. The handler will return to $I_{next}$, as though nothing has happened.&lt;/p>
&lt;h4 id="traps-and-system-calls">Traps and System Calls&lt;/h4>
&lt;p>Traps are intentional exceptions, likely to help interface between user program and the kernel, which is a &lt;em>system call&lt;/em>. Trap handlers also return to $I_{next}$ like interrupt handlers.&lt;/p>
&lt;p>System Calls:&lt;/p>
&lt;ul>
&lt;li>&lt;code>read&lt;/code>: file reading&lt;/li>
&lt;li>&lt;code>fork&lt;/code>: create a new process&lt;/li>
&lt;li>&lt;code>execve&lt;/code>: loading a new program&lt;/li>
&lt;li>&lt;code>exit&lt;/code>: terminating the current process&lt;/li>
&lt;/ul>
&lt;p>Remember that syscall runs in kernal mode and is thus different from normal procedure calls.&lt;/p>
&lt;h4 id="faults">Faults&lt;/h4>
&lt;p>Faults are error conditions that a handler might be able to correct. If the error is corrected, the handler will return to $I_{curr}$ (the faulting instruction), so it is re-executed. Otherwise, the handler will return to an abort routine to terminate the program&lt;/p>
&lt;h4 id="aborts">Aborts&lt;/h4>
&lt;p>Aborts result from unrecoverable fatal errors, for example, DRAM bits corruption.&lt;/p>
&lt;h3 id="example-exceptions-in-linuxx86-64-systems">Example Exceptions in Linux/x86-64 Systems&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Divide error&lt;/strong>: divide by zero, usually ends up in &lt;code>abort&lt;/code>. (Floating exceptions)&lt;/li>
&lt;li>&lt;strong>General protection fault&lt;/strong>: usually because the program references an undefined area of virtual memory, or tries to write to read-only text segment. Usually ends up in &lt;code>abort&lt;/code>. (Segmentation Fault)&lt;/li>
&lt;li>&lt;strong>Page Fault&lt;/strong>: Page of virtual memory is not resident in memory, needs to be retrieved from disk. The exception is &lt;code>fault&lt;/code>, and the handler will re-execute the faulting instruction after loading the page.&lt;/li>
&lt;li>&lt;strong>Machine check&lt;/strong>: Fatal hardware error is detected during execution of the faulting instruction. It directly goes to &lt;code>abort&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Syscalls:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Number&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>&lt;code>read&lt;/code>&lt;/td>
&lt;td>Read file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>&lt;code>write&lt;/code>&lt;/td>
&lt;td>write file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>&lt;code>open&lt;/code>&lt;/td>
&lt;td>open file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>&lt;code>close&lt;/code>&lt;/td>
&lt;td>close file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>&lt;code>stat&lt;/code>&lt;/td>
&lt;td>Get info about file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>&lt;code>mmap&lt;/code>&lt;/td>
&lt;td>map memory page to file&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>&lt;code>brk&lt;/code>&lt;/td>
&lt;td>Reset the top the heap&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>32&lt;/td>
&lt;td>&lt;code>dup2&lt;/code>&lt;/td>
&lt;td>copy file descriptor&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>33&lt;/td>
&lt;td>&lt;code>pause&lt;/code>&lt;/td>
&lt;td>suspend process until signal arrives&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>37&lt;/td>
&lt;td>&lt;code>alarm&lt;/code>&lt;/td>
&lt;td>schedule delivery of alarm signal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>39&lt;/td>
&lt;td>&lt;code>getpid&lt;/code>&lt;/td>
&lt;td>get process ID&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>57&lt;/td>
&lt;td>&lt;code>fork&lt;/code>&lt;/td>
&lt;td>create process&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>59&lt;/td>
&lt;td>&lt;code>execve&lt;/code>&lt;/td>
&lt;td>execute a program&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>60&lt;/td>
&lt;td>&lt;code>_exit&lt;/code>&lt;/td>
&lt;td>terminate process&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>61&lt;/td>
&lt;td>&lt;code>wait4&lt;/code>&lt;/td>
&lt;td>wait for a process to terminate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>62&lt;/td>
&lt;td>&lt;code>kill&lt;/code>&lt;/td>
&lt;td>send a signal to a process&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="c-and-syscalls">C and Syscalls&lt;/h3>
&lt;p>C/C++ programs can call syscall directly. For example,&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;hello, world&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">13&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>In syscall, the syscall ID is passed in &lt;code>%rax&lt;/code>, and arguments are passed through &lt;code>%rdi&lt;/code>, &lt;code>%rsi&lt;/code>, &lt;code>%rdi&lt;/code>, &lt;code>%r10&lt;/code>, &lt;code>%r8&lt;/code>, &lt;code>%r9&lt;/code>, in order.&lt;/p>
&lt;p>Equivalent Assembly Program&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-nasm" data-lang="nasm">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">.section&lt;/span> &lt;span class="nv">.data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">string:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">.ascii&lt;/span> &lt;span class="s">&amp;#34;hello, world\n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">string_end:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">.equ&lt;/span> &lt;span class="nv">len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nv">string_end&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nv">string&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">.section&lt;/span> &lt;span class="nv">.text&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">.global&lt;/span> &lt;span class="nv">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nl">main:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rax&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">syscall&lt;/span> &lt;span class="nv">code&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">write&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">Arg1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">stdout&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="nv">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rsi&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">Arg2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">string&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="nv">len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rdx&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">Arg3&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">length&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">60&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rax&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">syscall&lt;/span> &lt;span class="nv">code&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">_exit&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">60&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">movq&lt;/span> &lt;span class="kc">$&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">%&lt;/span>&lt;span class="nb">rdi&lt;/span> &lt;span class="err">#&lt;/span> &lt;span class="nv">Arg1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nv">exist&lt;/span> &lt;span class="nv">status&lt;/span> &lt;span class="err">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">syscall&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="processes">Processes&lt;/h2>
&lt;p>The concept of &lt;em>process&lt;/em> provides the illusion of&lt;/p>
&lt;ul>
&lt;li>our program has exclusive use of CPU and memory&lt;/li>
&lt;li>the processor executes the instructions of our program without interruption&lt;/li>
&lt;li>the code and data of the program appear to be the only objects in memory&lt;/li>
&lt;/ul>
&lt;p>A process is an instance of a program in execution. This means it includes:&lt;/p>
&lt;ul>
&lt;li>the code in memory,&lt;/li>
&lt;li>the data in memory,&lt;/li>
&lt;li>the stack of the program&lt;/li>
&lt;li>the general-purpose registers&lt;/li>
&lt;li>the program counters&lt;/li>
&lt;li>environment variables&lt;/li>
&lt;li>the set of open file descriptors&lt;/li>
&lt;/ul>
&lt;p>These states are the &lt;em>context&lt;/em> of the program.&lt;/p>
&lt;h3 id="logical-control-flow">Logical Control Flow&lt;/h3>
&lt;p>We perceive the illusionary control flow, that registers, memory, etc. are changed step by step completely according to the instruction set of our program. This control flow is called &lt;strong>Logical Control Flow&lt;/strong>.&lt;/p>
&lt;p>In reality, processes take turns to use the processor. Each process runs for a short period of time and is preempted (temporarily suspended), until the next turn.&lt;/p>
&lt;p>This short time period is called &lt;em>time slice&lt;/em>.&lt;/p>
&lt;h3 id="concurrent-flows">Concurrent Flows&lt;/h3>
&lt;p>A logical flow whose execution overlaps in time with another flow is called a concurrent flow. Two flows run &lt;em>concurrently&lt;/em>.&lt;/p>
&lt;h3 id="parallel-flows">Parallel Flows&lt;/h3>
&lt;p>The concurrent flows that run on different processor cores or computers are called &lt;em>parallel flows&lt;/em>.&lt;/p>
&lt;h3 id="private-address-space">Private Address Space&lt;/h3>
&lt;p>The illusion that the program has exclusive use of address space is provided by &lt;em>private address space&lt;/em>. This &amp;ldquo;space&amp;rdquo; of addresses cannot be read/written by other programs, and therefore is exclusive to the program.&lt;/p>
&lt;h3 id="user-mode-vs-kernel-mode">User Mode vs Kernel Mode&lt;/h3>
&lt;p>The OS restricts each process what instructions can be executed and what memory space can be accessed. The processor provides the capability with a &lt;code>mode bit&lt;/code>.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;code>mode bit&lt;/code>&lt;/th>
&lt;th>Mode&lt;/th>
&lt;th>Instruction&lt;/th>
&lt;th>Memory Space&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>Kernel Mode&lt;/td>
&lt;td>Any Instruction&lt;/td>
&lt;td>Any Memory&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>User Mode&lt;/td>
&lt;td>No Privileged Instruction&lt;/td>
&lt;td>No reference to code/data in kernel area&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Privileged Instruction: &lt;code>syscall&lt;/code> functions, including halt, change mode, I/O op, etc.&lt;/p>
&lt;h4 id="proc">/proc&lt;/h4>
&lt;p>&lt;code>/proc&lt;/code> is a Linux file system mount of the kernal data structure. It allows the user to access general system attributes.&lt;/p>
&lt;h3 id="context-switch">Context Switch&lt;/h3>
&lt;p>The kernel maintains a context for each process. The context is the state that the kernel needs to restart a preempted process.&lt;/p>
&lt;ul>
&lt;li>Values of general-purpose registers,&lt;/li>
&lt;li>floating-point registers&lt;/li>
&lt;li>program counter&lt;/li>
&lt;li>user&amp;rsquo;s stack&lt;/li>
&lt;li>status registers&lt;/li>
&lt;li>kernel&amp;rsquo;s stack&lt;/li>
&lt;li>various kernel data structure
&lt;ul>
&lt;li>page table&lt;/li>
&lt;li>process table&lt;/li>
&lt;li>file table&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Scheduling&lt;/strong>, deciding to preempt a process and restart a preempted process. This is handled by &lt;strong>scheduler&lt;/strong>, a code in the kernel.&lt;/p>
&lt;p>The kernel can decide to switch when the process is waiting for a read. The IO device can take care of the work, so the kernel will switch to another process, until the IO device sends an interrupt signalling successful transfer of data into the memory.&lt;/p>
&lt;h2 id="system-call-error-handling">System Call Error Handling&lt;/h2>
&lt;p>When a system level function encounter an error, they return $-1$, and set the global integer variable &lt;code>errno&lt;/code> to indicate what went wrong.&lt;/p>
&lt;p>An error checking fork function:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">unix_error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stderr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;%s: %s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">strerror&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">errno&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pid_t&lt;/span> &lt;span class="nf">Fork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pid_t&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">pid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fork&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// &amp;lt;- check for error return value
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">unix_error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Fork error&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="signals">Signals&lt;/h2>
&lt;p>A signal is a small message that notifies a process that an event of some type has occurred in the system.&lt;/p>
&lt;h3 id="sending-signal">Sending Signal&lt;/h3>
&lt;p>The kernel sends a signal because:&lt;/p>
&lt;ul>
&lt;li>the kernel detects a system event&lt;/li>
&lt;li>a process invoked &lt;code>kill&lt;/code> function&lt;/li>
&lt;/ul>
&lt;h4 id="process-group">Process Group&lt;/h4>
&lt;p>Each process belongs to exactly one process group. By default, a child process belongs to the same group as its parent.&lt;/p>
&lt;p>The Process Group ID can be read/write using &lt;code>getpgrp&lt;/code> and &lt;code>setpgid&lt;/code>.&lt;/p>
&lt;h4 id="binkill">&lt;code>/bin/kill&lt;/code>&lt;/h4>
&lt;p>&lt;code>/bin/kill -9 15213&lt;/code> sends a signal 9 (SIGKILL) to process 15213.&lt;/p>
&lt;p>&lt;code>/bin/kill -9 -15213&lt;/code> sends a signal 9 to ever process in group 15213&lt;/p>
&lt;h4 id="from-keyboard">from Keyboard&lt;/h4>
&lt;p>A Unix shell has at most 1 foreground job and zero or more background jobs. Typing &lt;kbd>ctrl&lt;/kbd> + &lt;kbd>c&lt;/kbd> causes the kernel to send SIGINT to every process in the foreground process group. &lt;kbd>ctrl&lt;/kbd> + &lt;kbd>z&lt;/kbd> sends SIGTSTP signal to every process in the foreground process group, which pauses them.&lt;/p>
&lt;h4 id="calling-kill-function">Calling &lt;code>kill&lt;/code> function&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;sys/types.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">kill&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pid_t&lt;/span> &lt;span class="n">pid&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">sig&lt;/span>&lt;span class="p">)&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>If :&lt;/p>
&lt;ul>
&lt;li>&lt;code>pid&lt;/code> &amp;gt; 0, send &lt;code>sig&lt;/code> to process[&lt;code>pid&lt;/code>]&lt;/li>
&lt;li>&lt;code>pid&lt;/code> = 0, send &lt;code>sig&lt;/code> to process group that current process belongs&lt;/li>
&lt;li>&lt;code>pid&lt;/code> &amp;lt; 0, send &lt;code>sig&lt;/code> to process group [|&lt;code>pid&lt;/code>|]&lt;/li>
&lt;/ul>
&lt;h4 id="calling-alarm-function">Calling &lt;code>alarm&lt;/code> function&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">alarm&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">secs&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Arranges the kernel to send SIGALRM signal to the calling process in &lt;code>secs&lt;/code> seconds. If secs == 0, then no new alarm is scheduled.&lt;/p>
&lt;p>It returns the remaining seconds of previous alarm.&lt;/p>
&lt;p>A call of &lt;code>alarm&lt;/code> cancels all previous &lt;code>alarm&lt;/code>s.&lt;/p>
&lt;h3 id="receiving-signal">Receiving Signal&lt;/h3>
&lt;p>The kernel checks for any &lt;em>pending and not blocked&lt;/em> signals, when switching a process from kernel mode to user mode, i.e. from an Interrupt, syscall, or context switching.&lt;/p>
&lt;p>If there is no such signals, then it will proceed to $I_{next}$. Otherwise, the kernel will choose a signal and force the process to receive it. The receipt will trigger some action, and once the action is completed, the kernel proceeds to $I_{next}$.&lt;/p>
&lt;p>There is a default action associated with each signal; the user program can change it by using a &lt;code>signal&lt;/code> function&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;signal.h&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="nf">void&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">sighandler_t&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sighandler_t&lt;/span> &lt;span class="nf">signal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">signum&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sighandler_t&lt;/span> &lt;span class="n">handler&lt;/span>&lt;span class="p">);&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Then &lt;code>handler&lt;/code> can be SIG_IGN (ignore), SIG_DFL (default), or the address of a user-defined function, a *signal handler.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Figure 8.5, CSAPP&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>